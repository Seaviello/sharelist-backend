// Code generated by Prisma (prisma@1.20.6). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode, GraphQLSchema } from "graphql";
import { makePrismaClientClass, BaseClientOptions } from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export interface Exists {
  item: (where?: ItemWhereInput) => Promise<boolean>;
  list: (where?: ListWhereInput) => Promise<boolean>;
  permission: (where?: PermissionWhereInput) => Promise<boolean>;
  stock: (where?: StockWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  item: (where: ItemWhereUniqueInput) => ItemPromise;
  items: (
    args?: {
      where?: ItemWhereInput;
      orderBy?: ItemOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Item>;
  itemsConnection: (
    args?: {
      where?: ItemWhereInput;
      orderBy?: ItemOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ItemConnectionPromise;
  list: (where: ListWhereUniqueInput) => ListPromise;
  lists: (
    args?: {
      where?: ListWhereInput;
      orderBy?: ListOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<List>;
  listsConnection: (
    args?: {
      where?: ListWhereInput;
      orderBy?: ListOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ListConnectionPromise;
  permission: (where: PermissionWhereUniqueInput) => PermissionPromise;
  permissions: (
    args?: {
      where?: PermissionWhereInput;
      orderBy?: PermissionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Permission>;
  permissionsConnection: (
    args?: {
      where?: PermissionWhereInput;
      orderBy?: PermissionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => PermissionConnectionPromise;
  stock: (where: StockWhereUniqueInput) => StockPromise;
  stocks: (
    args?: {
      where?: StockWhereInput;
      orderBy?: StockOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Stock>;
  stocksConnection: (
    args?: {
      where?: StockWhereInput;
      orderBy?: StockOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => StockConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserPromise;
  users: (
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<User>;
  usersConnection: (
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => UserConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createItem: (data: ItemCreateInput) => ItemPromise;
  updateItem: (
    args: { data: ItemUpdateInput; where: ItemWhereUniqueInput }
  ) => ItemPromise;
  updateManyItems: (
    args: { data: ItemUpdateManyMutationInput; where?: ItemWhereInput }
  ) => BatchPayloadPromise;
  upsertItem: (
    args: {
      where: ItemWhereUniqueInput;
      create: ItemCreateInput;
      update: ItemUpdateInput;
    }
  ) => ItemPromise;
  deleteItem: (where: ItemWhereUniqueInput) => ItemPromise;
  deleteManyItems: (where?: ItemWhereInput) => BatchPayloadPromise;
  createList: (data: ListCreateInput) => ListPromise;
  updateList: (
    args: { data: ListUpdateInput; where: ListWhereUniqueInput }
  ) => ListPromise;
  updateManyLists: (
    args: { data: ListUpdateManyMutationInput; where?: ListWhereInput }
  ) => BatchPayloadPromise;
  upsertList: (
    args: {
      where: ListWhereUniqueInput;
      create: ListCreateInput;
      update: ListUpdateInput;
    }
  ) => ListPromise;
  deleteList: (where: ListWhereUniqueInput) => ListPromise;
  deleteManyLists: (where?: ListWhereInput) => BatchPayloadPromise;
  createPermission: (data: PermissionCreateInput) => PermissionPromise;
  updatePermission: (
    args: { data: PermissionUpdateInput; where: PermissionWhereUniqueInput }
  ) => PermissionPromise;
  updateManyPermissions: (
    args: {
      data: PermissionUpdateManyMutationInput;
      where?: PermissionWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertPermission: (
    args: {
      where: PermissionWhereUniqueInput;
      create: PermissionCreateInput;
      update: PermissionUpdateInput;
    }
  ) => PermissionPromise;
  deletePermission: (where: PermissionWhereUniqueInput) => PermissionPromise;
  deleteManyPermissions: (where?: PermissionWhereInput) => BatchPayloadPromise;
  createStock: (data: StockCreateInput) => StockPromise;
  updateStock: (
    args: { data: StockUpdateInput; where: StockWhereUniqueInput }
  ) => StockPromise;
  updateManyStocks: (
    args: { data: StockUpdateManyMutationInput; where?: StockWhereInput }
  ) => BatchPayloadPromise;
  upsertStock: (
    args: {
      where: StockWhereUniqueInput;
      create: StockCreateInput;
      update: StockUpdateInput;
    }
  ) => StockPromise;
  deleteStock: (where: StockWhereUniqueInput) => StockPromise;
  deleteManyStocks: (where?: StockWhereInput) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (
    args: { data: UserUpdateInput; where: UserWhereUniqueInput }
  ) => UserPromise;
  updateManyUsers: (
    args: { data: UserUpdateManyMutationInput; where?: UserWhereInput }
  ) => BatchPayloadPromise;
  upsertUser: (
    args: {
      where: UserWhereUniqueInput;
      create: UserCreateInput;
      update: UserUpdateInput;
    }
  ) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  item: (
    where?: ItemSubscriptionWhereInput
  ) => ItemSubscriptionPayloadSubscription;
  list: (
    where?: ListSubscriptionWhereInput
  ) => ListSubscriptionPayloadSubscription;
  permission: (
    where?: PermissionSubscriptionWhereInput
  ) => PermissionSubscriptionPayloadSubscription;
  stock: (
    where?: StockSubscriptionWhereInput
  ) => StockSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type StockStatus = "AVAILABLE" | "LIMITED" | "OUT";

export type PermissionType = "ADMIN" | "EDITOR" | "READONLY";

export type ListOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "title_ASC"
  | "title_DESC"
  | "type_ASC"
  | "type_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type PermissionOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "type_ASC"
  | "type_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ListType = "INVENTORY" | "CHECKLIST";

export type ItemOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "title_ASC"
  | "title_DESC"
  | "description_ASC"
  | "description_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type Unit = "COUNT" | "MG" | "ML";

export type StockOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "quantity_ASC"
  | "quantity_DESC"
  | "status_ASC"
  | "status_DESC"
  | "unit_ASC"
  | "unit_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "email_ASC"
  | "email_DESC"
  | "password_ASC"
  | "password_DESC"
  | "resetToken_ASC"
  | "resetToken_DESC"
  | "resetTokenExpiry_ASC"
  | "resetTokenExpiry_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export interface UserUpdateOneRequiredWithoutItemsInput {
  create?: UserCreateWithoutItemsInput;
  update?: UserUpdateWithoutItemsDataInput;
  upsert?: UserUpsertWithoutItemsInput;
  connect?: UserWhereUniqueInput;
}

export type ItemWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface PermissionUpdateWithWhereUniqueWithoutListIdInput {
  where: PermissionWhereUniqueInput;
  data: PermissionUpdateWithoutListIdDataInput;
}

export interface PermissionWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  userId?: UserWhereInput;
  listId?: ListWhereInput;
  type?: PermissionType;
  type_not?: PermissionType;
  type_in?: PermissionType[] | PermissionType;
  type_not_in?: PermissionType[] | PermissionType;
  AND?: PermissionWhereInput[] | PermissionWhereInput;
  OR?: PermissionWhereInput[] | PermissionWhereInput;
  NOT?: PermissionWhereInput[] | PermissionWhereInput;
}

export interface ItemCreateWithoutOwnerInput {
  title: String;
  description?: String;
}

export interface PermissionUpsertWithWhereUniqueWithoutUserIdInput {
  where: PermissionWhereUniqueInput;
  update: PermissionUpdateWithoutUserIdDataInput;
  create: PermissionCreateWithoutUserIdInput;
}

export interface ListCreateOneInput {
  create?: ListCreateInput;
  connect?: ListWhereUniqueInput;
}

export interface PermissionUpdateWithoutListIdDataInput {
  userId?: UserUpdateOneRequiredWithoutPermissionsInput;
  type?: PermissionType;
}

export interface ListCreateInput {
  title: String;
  type: ListType;
  owner: UserCreateOneWithoutListsInput;
  permissions?: PermissionCreateManyWithoutListIdInput;
  parentList?: ListCreateOneInput;
  items?: ItemCreateManyInput;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: UserWhereInput;
  AND?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  OR?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  NOT?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
}

export interface UserCreateOneWithoutListsInput {
  create?: UserCreateWithoutListsInput;
  connect?: UserWhereUniqueInput;
}

export interface StockSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: StockWhereInput;
  AND?: StockSubscriptionWhereInput[] | StockSubscriptionWhereInput;
  OR?: StockSubscriptionWhereInput[] | StockSubscriptionWhereInput;
  NOT?: StockSubscriptionWhereInput[] | StockSubscriptionWhereInput;
}

export interface UserCreateWithoutListsInput {
  name: String;
  email: String;
  password: String;
  resetToken?: String;
  resetTokenExpiry?: Float;
  items?: ItemCreateManyWithoutOwnerInput;
  permissions?: PermissionCreateManyWithoutUserIdInput;
}

export interface ListSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ListWhereInput;
  AND?: ListSubscriptionWhereInput[] | ListSubscriptionWhereInput;
  OR?: ListSubscriptionWhereInput[] | ListSubscriptionWhereInput;
  NOT?: ListSubscriptionWhereInput[] | ListSubscriptionWhereInput;
}

export interface PermissionCreateManyWithoutUserIdInput {
  create?:
    | PermissionCreateWithoutUserIdInput[]
    | PermissionCreateWithoutUserIdInput;
  connect?: PermissionWhereUniqueInput[] | PermissionWhereUniqueInput;
}

export interface UserUpdateManyMutationInput {
  name?: String;
  email?: String;
  password?: String;
  resetToken?: String;
  resetTokenExpiry?: Float;
}

export interface PermissionCreateWithoutUserIdInput {
  listId: ListCreateOneWithoutPermissionsInput;
  type: PermissionType;
}

export interface UserUpdateInput {
  name?: String;
  email?: String;
  password?: String;
  resetToken?: String;
  resetTokenExpiry?: Float;
  lists?: ListUpdateManyWithoutOwnerInput;
  items?: ItemUpdateManyWithoutOwnerInput;
  permissions?: PermissionUpdateManyWithoutUserIdInput;
}

export interface ListCreateOneWithoutPermissionsInput {
  create?: ListCreateWithoutPermissionsInput;
  connect?: ListWhereUniqueInput;
}

export interface StockUpdateManyMutationInput {
  quantity?: Int;
  status?: StockStatus;
  unit?: Unit;
}

export interface ListCreateWithoutPermissionsInput {
  title: String;
  type: ListType;
  owner: UserCreateOneWithoutListsInput;
  parentList?: ListCreateOneInput;
  items?: ItemCreateManyInput;
}

export interface ItemUpsertNestedInput {
  update: ItemUpdateDataInput;
  create: ItemCreateInput;
}

export interface ItemCreateManyInput {
  create?: ItemCreateInput[] | ItemCreateInput;
  connect?: ItemWhereUniqueInput[] | ItemWhereUniqueInput;
}

export interface ListUpdateOneRequiredInput {
  create?: ListCreateInput;
  update?: ListUpdateDataInput;
  upsert?: ListUpsertNestedInput;
  connect?: ListWhereUniqueInput;
}

export interface ItemUpdateInput {
  title?: String;
  description?: String;
  owner?: UserUpdateOneRequiredWithoutItemsInput;
}

export interface StockUpdateInput {
  listId?: ListUpdateOneRequiredInput;
  itemId?: ItemUpdateOneRequiredInput;
  quantity?: Int;
  status?: StockStatus;
  unit?: Unit;
}

export interface ListUpsertNestedInput {
  update: ListUpdateDataInput;
  create: ListCreateInput;
}

export interface StockCreateInput {
  listId: ListCreateOneInput;
  itemId: ItemCreateOneInput;
  quantity?: Int;
  status?: StockStatus;
  unit?: Unit;
}

export interface UserUpdateWithoutItemsDataInput {
  name?: String;
  email?: String;
  password?: String;
  resetToken?: String;
  resetTokenExpiry?: Float;
  lists?: ListUpdateManyWithoutOwnerInput;
  permissions?: PermissionUpdateManyWithoutUserIdInput;
}

export interface PermissionUpdateManyMutationInput {
  type?: PermissionType;
}

export interface ListUpdateManyWithoutOwnerInput {
  create?: ListCreateWithoutOwnerInput[] | ListCreateWithoutOwnerInput;
  delete?: ListWhereUniqueInput[] | ListWhereUniqueInput;
  connect?: ListWhereUniqueInput[] | ListWhereUniqueInput;
  disconnect?: ListWhereUniqueInput[] | ListWhereUniqueInput;
  update?:
    | ListUpdateWithWhereUniqueWithoutOwnerInput[]
    | ListUpdateWithWhereUniqueWithoutOwnerInput;
  upsert?:
    | ListUpsertWithWhereUniqueWithoutOwnerInput[]
    | ListUpsertWithWhereUniqueWithoutOwnerInput;
}

export interface PermissionCreateInput {
  userId: UserCreateOneWithoutPermissionsInput;
  listId: ListCreateOneWithoutPermissionsInput;
  type: PermissionType;
}

export interface ListUpdateWithWhereUniqueWithoutOwnerInput {
  where: ListWhereUniqueInput;
  data: ListUpdateWithoutOwnerDataInput;
}

export type UserWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  email?: String;
}>;

export interface ListUpdateWithoutOwnerDataInput {
  title?: String;
  type?: ListType;
  permissions?: PermissionUpdateManyWithoutListIdInput;
  parentList?: ListUpdateOneInput;
  items?: ItemUpdateManyInput;
}

export interface ItemUpdateManyMutationInput {
  title?: String;
  description?: String;
}

export interface PermissionUpdateManyWithoutListIdInput {
  create?:
    | PermissionCreateWithoutListIdInput[]
    | PermissionCreateWithoutListIdInput;
  delete?: PermissionWhereUniqueInput[] | PermissionWhereUniqueInput;
  connect?: PermissionWhereUniqueInput[] | PermissionWhereUniqueInput;
  disconnect?: PermissionWhereUniqueInput[] | PermissionWhereUniqueInput;
  update?:
    | PermissionUpdateWithWhereUniqueWithoutListIdInput[]
    | PermissionUpdateWithWhereUniqueWithoutListIdInput;
  upsert?:
    | PermissionUpsertWithWhereUniqueWithoutListIdInput[]
    | PermissionUpsertWithWhereUniqueWithoutListIdInput;
}

export interface ListUpsertWithWhereUniqueWithoutOwnerInput {
  where: ListWhereUniqueInput;
  update: ListUpdateWithoutOwnerDataInput;
  create: ListCreateWithoutOwnerInput;
}

export interface ItemWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  owner?: UserWhereInput;
  AND?: ItemWhereInput[] | ItemWhereInput;
  OR?: ItemWhereInput[] | ItemWhereInput;
  NOT?: ItemWhereInput[] | ItemWhereInput;
}

export interface ItemCreateInput {
  title: String;
  description?: String;
  owner: UserCreateOneWithoutItemsInput;
}

export interface UserUpsertWithoutListsInput {
  update: UserUpdateWithoutListsDataInput;
  create: UserCreateWithoutListsInput;
}

export interface UserCreateWithoutItemsInput {
  name: String;
  email: String;
  password: String;
  resetToken?: String;
  resetTokenExpiry?: Float;
  lists?: ListCreateManyWithoutOwnerInput;
  permissions?: PermissionCreateManyWithoutUserIdInput;
}

export interface UserUpdateOneRequiredWithoutPermissionsInput {
  create?: UserCreateWithoutPermissionsInput;
  update?: UserUpdateWithoutPermissionsDataInput;
  upsert?: UserUpsertWithoutPermissionsInput;
  connect?: UserWhereUniqueInput;
}

export interface ListCreateWithoutOwnerInput {
  title: String;
  type: ListType;
  permissions?: PermissionCreateManyWithoutListIdInput;
  parentList?: ListCreateOneInput;
  items?: ItemCreateManyInput;
}

export interface UserUpdateWithoutPermissionsDataInput {
  name?: String;
  email?: String;
  password?: String;
  resetToken?: String;
  resetTokenExpiry?: Float;
  lists?: ListUpdateManyWithoutOwnerInput;
  items?: ItemUpdateManyWithoutOwnerInput;
}

export interface PermissionCreateWithoutListIdInput {
  userId: UserCreateOneWithoutPermissionsInput;
  type: PermissionType;
}

export interface ItemUpdateManyWithoutOwnerInput {
  create?: ItemCreateWithoutOwnerInput[] | ItemCreateWithoutOwnerInput;
  delete?: ItemWhereUniqueInput[] | ItemWhereUniqueInput;
  connect?: ItemWhereUniqueInput[] | ItemWhereUniqueInput;
  disconnect?: ItemWhereUniqueInput[] | ItemWhereUniqueInput;
  update?:
    | ItemUpdateWithWhereUniqueWithoutOwnerInput[]
    | ItemUpdateWithWhereUniqueWithoutOwnerInput;
  upsert?:
    | ItemUpsertWithWhereUniqueWithoutOwnerInput[]
    | ItemUpsertWithWhereUniqueWithoutOwnerInput;
}

export interface UserCreateWithoutPermissionsInput {
  name: String;
  email: String;
  password: String;
  resetToken?: String;
  resetTokenExpiry?: Float;
  lists?: ListCreateManyWithoutOwnerInput;
  items?: ItemCreateManyWithoutOwnerInput;
}

export interface ItemUpdateWithWhereUniqueWithoutOwnerInput {
  where: ItemWhereUniqueInput;
  data: ItemUpdateWithoutOwnerDataInput;
}

export interface UserWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  password?: String;
  password_not?: String;
  password_in?: String[] | String;
  password_not_in?: String[] | String;
  password_lt?: String;
  password_lte?: String;
  password_gt?: String;
  password_gte?: String;
  password_contains?: String;
  password_not_contains?: String;
  password_starts_with?: String;
  password_not_starts_with?: String;
  password_ends_with?: String;
  password_not_ends_with?: String;
  resetToken?: String;
  resetToken_not?: String;
  resetToken_in?: String[] | String;
  resetToken_not_in?: String[] | String;
  resetToken_lt?: String;
  resetToken_lte?: String;
  resetToken_gt?: String;
  resetToken_gte?: String;
  resetToken_contains?: String;
  resetToken_not_contains?: String;
  resetToken_starts_with?: String;
  resetToken_not_starts_with?: String;
  resetToken_ends_with?: String;
  resetToken_not_ends_with?: String;
  resetTokenExpiry?: Float;
  resetTokenExpiry_not?: Float;
  resetTokenExpiry_in?: Float[] | Float;
  resetTokenExpiry_not_in?: Float[] | Float;
  resetTokenExpiry_lt?: Float;
  resetTokenExpiry_lte?: Float;
  resetTokenExpiry_gt?: Float;
  resetTokenExpiry_gte?: Float;
  lists_every?: ListWhereInput;
  lists_some?: ListWhereInput;
  lists_none?: ListWhereInput;
  items_every?: ItemWhereInput;
  items_some?: ItemWhereInput;
  items_none?: ItemWhereInput;
  permissions_every?: PermissionWhereInput;
  permissions_some?: PermissionWhereInput;
  permissions_none?: PermissionWhereInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: UserWhereInput[] | UserWhereInput;
  OR?: UserWhereInput[] | UserWhereInput;
  NOT?: UserWhereInput[] | UserWhereInput;
}

export interface ItemUpdateWithoutOwnerDataInput {
  title?: String;
  description?: String;
}

export interface PermissionSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: PermissionWhereInput;
  AND?: PermissionSubscriptionWhereInput[] | PermissionSubscriptionWhereInput;
  OR?: PermissionSubscriptionWhereInput[] | PermissionSubscriptionWhereInput;
  NOT?: PermissionSubscriptionWhereInput[] | PermissionSubscriptionWhereInput;
}

export interface ItemUpsertWithWhereUniqueWithoutOwnerInput {
  where: ItemWhereUniqueInput;
  update: ItemUpdateWithoutOwnerDataInput;
  create: ItemCreateWithoutOwnerInput;
}

export type ListWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface UserUpsertWithoutPermissionsInput {
  update: UserUpdateWithoutPermissionsDataInput;
  create: UserCreateWithoutPermissionsInput;
}

export type PermissionWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface PermissionUpsertWithWhereUniqueWithoutListIdInput {
  where: PermissionWhereUniqueInput;
  update: PermissionUpdateWithoutListIdDataInput;
  create: PermissionCreateWithoutListIdInput;
}

export type StockWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface ListUpdateOneInput {
  create?: ListCreateInput;
  update?: ListUpdateDataInput;
  upsert?: ListUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: ListWhereUniqueInput;
}

export interface StockWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  listId?: ListWhereInput;
  itemId?: ItemWhereInput;
  quantity?: Int;
  quantity_not?: Int;
  quantity_in?: Int[] | Int;
  quantity_not_in?: Int[] | Int;
  quantity_lt?: Int;
  quantity_lte?: Int;
  quantity_gt?: Int;
  quantity_gte?: Int;
  status?: StockStatus;
  status_not?: StockStatus;
  status_in?: StockStatus[] | StockStatus;
  status_not_in?: StockStatus[] | StockStatus;
  unit?: Unit;
  unit_not?: Unit;
  unit_in?: Unit[] | Unit;
  unit_not_in?: Unit[] | Unit;
  AND?: StockWhereInput[] | StockWhereInput;
  OR?: StockWhereInput[] | StockWhereInput;
  NOT?: StockWhereInput[] | StockWhereInput;
}

export interface ListUpdateDataInput {
  title?: String;
  type?: ListType;
  owner?: UserUpdateOneRequiredWithoutListsInput;
  permissions?: PermissionUpdateManyWithoutListIdInput;
  parentList?: ListUpdateOneInput;
  items?: ItemUpdateManyInput;
}

export interface ListUpdateManyMutationInput {
  title?: String;
  type?: ListType;
}

export interface UserUpdateOneRequiredWithoutListsInput {
  create?: UserCreateWithoutListsInput;
  update?: UserUpdateWithoutListsDataInput;
  upsert?: UserUpsertWithoutListsInput;
  connect?: UserWhereUniqueInput;
}

export interface UserUpsertWithoutItemsInput {
  update: UserUpdateWithoutItemsDataInput;
  create: UserCreateWithoutItemsInput;
}

export interface UserUpdateWithoutListsDataInput {
  name?: String;
  email?: String;
  password?: String;
  resetToken?: String;
  resetTokenExpiry?: Float;
  items?: ItemUpdateManyWithoutOwnerInput;
  permissions?: PermissionUpdateManyWithoutUserIdInput;
}

export interface UserCreateOneWithoutItemsInput {
  create?: UserCreateWithoutItemsInput;
  connect?: UserWhereUniqueInput;
}

export interface PermissionUpdateManyWithoutUserIdInput {
  create?:
    | PermissionCreateWithoutUserIdInput[]
    | PermissionCreateWithoutUserIdInput;
  delete?: PermissionWhereUniqueInput[] | PermissionWhereUniqueInput;
  connect?: PermissionWhereUniqueInput[] | PermissionWhereUniqueInput;
  disconnect?: PermissionWhereUniqueInput[] | PermissionWhereUniqueInput;
  update?:
    | PermissionUpdateWithWhereUniqueWithoutUserIdInput[]
    | PermissionUpdateWithWhereUniqueWithoutUserIdInput;
  upsert?:
    | PermissionUpsertWithWhereUniqueWithoutUserIdInput[]
    | PermissionUpsertWithWhereUniqueWithoutUserIdInput;
}

export interface PermissionCreateManyWithoutListIdInput {
  create?:
    | PermissionCreateWithoutListIdInput[]
    | PermissionCreateWithoutListIdInput;
  connect?: PermissionWhereUniqueInput[] | PermissionWhereUniqueInput;
}

export interface PermissionUpdateWithWhereUniqueWithoutUserIdInput {
  where: PermissionWhereUniqueInput;
  data: PermissionUpdateWithoutUserIdDataInput;
}

export interface ItemCreateManyWithoutOwnerInput {
  create?: ItemCreateWithoutOwnerInput[] | ItemCreateWithoutOwnerInput;
  connect?: ItemWhereUniqueInput[] | ItemWhereUniqueInput;
}

export interface PermissionUpdateWithoutUserIdDataInput {
  listId?: ListUpdateOneRequiredWithoutPermissionsInput;
  type?: PermissionType;
}

export interface ItemSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ItemWhereInput;
  AND?: ItemSubscriptionWhereInput[] | ItemSubscriptionWhereInput;
  OR?: ItemSubscriptionWhereInput[] | ItemSubscriptionWhereInput;
  NOT?: ItemSubscriptionWhereInput[] | ItemSubscriptionWhereInput;
}

export interface ListUpdateOneRequiredWithoutPermissionsInput {
  create?: ListCreateWithoutPermissionsInput;
  update?: ListUpdateWithoutPermissionsDataInput;
  upsert?: ListUpsertWithoutPermissionsInput;
  connect?: ListWhereUniqueInput;
}

export interface ItemUpdateOneRequiredInput {
  create?: ItemCreateInput;
  update?: ItemUpdateDataInput;
  upsert?: ItemUpsertNestedInput;
  connect?: ItemWhereUniqueInput;
}

export interface ListUpdateWithoutPermissionsDataInput {
  title?: String;
  type?: ListType;
  owner?: UserUpdateOneRequiredWithoutListsInput;
  parentList?: ListUpdateOneInput;
  items?: ItemUpdateManyInput;
}

export interface PermissionUpdateInput {
  userId?: UserUpdateOneRequiredWithoutPermissionsInput;
  listId?: ListUpdateOneRequiredWithoutPermissionsInput;
  type?: PermissionType;
}

export interface ItemUpdateManyInput {
  create?: ItemCreateInput[] | ItemCreateInput;
  update?:
    | ItemUpdateWithWhereUniqueNestedInput[]
    | ItemUpdateWithWhereUniqueNestedInput;
  upsert?:
    | ItemUpsertWithWhereUniqueNestedInput[]
    | ItemUpsertWithWhereUniqueNestedInput;
  delete?: ItemWhereUniqueInput[] | ItemWhereUniqueInput;
  connect?: ItemWhereUniqueInput[] | ItemWhereUniqueInput;
  disconnect?: ItemWhereUniqueInput[] | ItemWhereUniqueInput;
}

export interface UserCreateOneWithoutPermissionsInput {
  create?: UserCreateWithoutPermissionsInput;
  connect?: UserWhereUniqueInput;
}

export interface ListUpsertWithoutPermissionsInput {
  update: ListUpdateWithoutPermissionsDataInput;
  create: ListCreateWithoutPermissionsInput;
}

export interface ItemUpsertWithWhereUniqueNestedInput {
  where: ItemWhereUniqueInput;
  update: ItemUpdateDataInput;
  create: ItemCreateInput;
}

export interface ItemUpdateDataInput {
  title?: String;
  description?: String;
  owner?: UserUpdateOneRequiredWithoutItemsInput;
}

export interface ItemUpdateWithWhereUniqueNestedInput {
  where: ItemWhereUniqueInput;
  data: ItemUpdateDataInput;
}

export interface ListWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  type?: ListType;
  type_not?: ListType;
  type_in?: ListType[] | ListType;
  type_not_in?: ListType[] | ListType;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  owner?: UserWhereInput;
  permissions_every?: PermissionWhereInput;
  permissions_some?: PermissionWhereInput;
  permissions_none?: PermissionWhereInput;
  parentList?: ListWhereInput;
  items_every?: ItemWhereInput;
  items_some?: ItemWhereInput;
  items_none?: ItemWhereInput;
  AND?: ListWhereInput[] | ListWhereInput;
  OR?: ListWhereInput[] | ListWhereInput;
  NOT?: ListWhereInput[] | ListWhereInput;
}

export interface ListCreateManyWithoutOwnerInput {
  create?: ListCreateWithoutOwnerInput[] | ListCreateWithoutOwnerInput;
  connect?: ListWhereUniqueInput[] | ListWhereUniqueInput;
}

export interface ListUpdateInput {
  title?: String;
  type?: ListType;
  owner?: UserUpdateOneRequiredWithoutListsInput;
  permissions?: PermissionUpdateManyWithoutListIdInput;
  parentList?: ListUpdateOneInput;
  items?: ItemUpdateManyInput;
}

export interface ItemCreateOneInput {
  create?: ItemCreateInput;
  connect?: ItemWhereUniqueInput;
}

export interface UserCreateInput {
  name: String;
  email: String;
  password: String;
  resetToken?: String;
  resetTokenExpiry?: Float;
  lists?: ListCreateManyWithoutOwnerInput;
  items?: ItemCreateManyWithoutOwnerInput;
  permissions?: PermissionCreateManyWithoutUserIdInput;
}

export interface NodeNode {
  id: ID_Output;
}

export interface UserPreviousValues {
  id: ID_Output;
  name: String;
  email: String;
  password: String;
  resetToken?: String;
  resetTokenExpiry?: Float;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  resetToken: () => Promise<String>;
  resetTokenExpiry: () => Promise<Float>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  resetToken: () => Promise<AsyncIterator<String>>;
  resetTokenExpiry: () => Promise<AsyncIterator<Float>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ListEdge {
  cursor: String;
}

export interface ListEdgePromise extends Promise<ListEdge>, Fragmentable {
  node: <T = List>() => T;
  cursor: () => Promise<String>;
}

export interface ListEdgeSubscription
  extends Promise<AsyncIterator<ListEdge>>,
    Fragmentable {
  node: <T = ListSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface List {
  id: ID_Output;
  title: String;
  type: ListType;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ListPromise extends Promise<List>, Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  type: () => Promise<ListType>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  owner: <T = User>() => T;
  permissions: <T = FragmentableArray<Permission>>(
    args?: {
      where?: PermissionWhereInput;
      orderBy?: PermissionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  parentList: <T = List>() => T;
  items: <T = FragmentableArray<Item>>(
    args?: {
      where?: ItemWhereInput;
      orderBy?: ItemOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface ListSubscription
  extends Promise<AsyncIterator<List>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  type: () => Promise<AsyncIterator<ListType>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  owner: <T = UserSubscription>() => T;
  permissions: <T = Promise<AsyncIterator<PermissionSubscription>>>(
    args?: {
      where?: PermissionWhereInput;
      orderBy?: PermissionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  parentList: <T = ListSubscription>() => T;
  items: <T = Promise<AsyncIterator<ItemSubscription>>>(
    args?: {
      where?: ItemWhereInput;
      orderBy?: ItemOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface ListConnection {}

export interface ListConnectionPromise
  extends Promise<ListConnection>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = FragmentableArray<ListEdge>>() => T;
  aggregate: <T = AggregateList>() => T;
}

export interface ListConnectionSubscription
  extends Promise<AsyncIterator<ListConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ListEdgeSubscription>>>() => T;
  aggregate: <T = AggregateListSubscription>() => T;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateItem {
  count: Int;
}

export interface AggregateItemPromise
  extends Promise<AggregateItem>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateItemSubscription
  extends Promise<AsyncIterator<AggregateItem>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserConnection {}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUser>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface StockPreviousValues {
  id: ID_Output;
  quantity?: Int;
  status?: StockStatus;
  unit?: Unit;
}

export interface StockPreviousValuesPromise
  extends Promise<StockPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  quantity: () => Promise<Int>;
  status: () => Promise<StockStatus>;
  unit: () => Promise<Unit>;
}

export interface StockPreviousValuesSubscription
  extends Promise<AsyncIterator<StockPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  quantity: () => Promise<AsyncIterator<Int>>;
  status: () => Promise<AsyncIterator<StockStatus>>;
  unit: () => Promise<AsyncIterator<Unit>>;
}

export interface PermissionPreviousValues {
  id: ID_Output;
  type: PermissionType;
}

export interface PermissionPreviousValuesPromise
  extends Promise<PermissionPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  type: () => Promise<PermissionType>;
}

export interface PermissionPreviousValuesSubscription
  extends Promise<AsyncIterator<PermissionPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  type: () => Promise<AsyncIterator<PermissionType>>;
}

export interface UserEdge {
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = User>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ItemEdge {
  cursor: String;
}

export interface ItemEdgePromise extends Promise<ItemEdge>, Fragmentable {
  node: <T = Item>() => T;
  cursor: () => Promise<String>;
}

export interface ItemEdgeSubscription
  extends Promise<AsyncIterator<ItemEdge>>,
    Fragmentable {
  node: <T = ItemSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface StockEdge {
  cursor: String;
}

export interface StockEdgePromise extends Promise<StockEdge>, Fragmentable {
  node: <T = Stock>() => T;
  cursor: () => Promise<String>;
}

export interface StockEdgeSubscription
  extends Promise<AsyncIterator<StockEdge>>,
    Fragmentable {
  node: <T = StockSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface StockSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface StockSubscriptionPayloadPromise
  extends Promise<StockSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = Stock>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = StockPreviousValues>() => T;
}

export interface StockSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<StockSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = StockSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = StockPreviousValuesSubscription>() => T;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = User>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValues>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface Item {
  id: ID_Output;
  title: String;
  description?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ItemPromise extends Promise<Item>, Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  description: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  owner: <T = User>() => T;
}

export interface ItemSubscription
  extends Promise<AsyncIterator<Item>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  owner: <T = UserSubscription>() => T;
}

export interface Permission {
  id: ID_Output;
  type: PermissionType;
}

export interface PermissionPromise extends Promise<Permission>, Fragmentable {
  id: () => Promise<ID_Output>;
  userId: <T = User>() => T;
  listId: <T = List>() => T;
  type: () => Promise<PermissionType>;
}

export interface PermissionSubscription
  extends Promise<AsyncIterator<Permission>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  userId: <T = UserSubscription>() => T;
  listId: <T = ListSubscription>() => T;
  type: () => Promise<AsyncIterator<PermissionType>>;
}

export interface ItemSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface ItemSubscriptionPayloadPromise
  extends Promise<ItemSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = Item>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ItemPreviousValues>() => T;
}

export interface ItemSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ItemSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ItemSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ItemPreviousValuesSubscription>() => T;
}

export interface AggregatePermission {
  count: Int;
}

export interface AggregatePermissionPromise
  extends Promise<AggregatePermission>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePermissionSubscription
  extends Promise<AsyncIterator<AggregatePermission>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ItemPreviousValues {
  id: ID_Output;
  title: String;
  description?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ItemPreviousValuesPromise
  extends Promise<ItemPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  description: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ItemPreviousValuesSubscription
  extends Promise<AsyncIterator<ItemPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface PermissionConnection {}

export interface PermissionConnectionPromise
  extends Promise<PermissionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = FragmentableArray<PermissionEdge>>() => T;
  aggregate: <T = AggregatePermission>() => T;
}

export interface PermissionConnectionSubscription
  extends Promise<AsyncIterator<PermissionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PermissionEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePermissionSubscription>() => T;
}

export interface ItemConnection {}

export interface ItemConnectionPromise
  extends Promise<ItemConnection>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = FragmentableArray<ItemEdge>>() => T;
  aggregate: <T = AggregateItem>() => T;
}

export interface ItemConnectionSubscription
  extends Promise<AsyncIterator<ItemConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ItemEdgeSubscription>>>() => T;
  aggregate: <T = AggregateItemSubscription>() => T;
}

export interface AggregateStock {
  count: Int;
}

export interface AggregateStockPromise
  extends Promise<AggregateStock>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateStockSubscription
  extends Promise<AsyncIterator<AggregateStock>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface User {
  id: ID_Output;
  name: String;
  email: String;
  password: String;
  resetToken?: String;
  resetTokenExpiry?: Float;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  resetToken: () => Promise<String>;
  resetTokenExpiry: () => Promise<Float>;
  lists: <T = FragmentableArray<List>>(
    args?: {
      where?: ListWhereInput;
      orderBy?: ListOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  items: <T = FragmentableArray<Item>>(
    args?: {
      where?: ItemWhereInput;
      orderBy?: ItemOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  permissions: <T = FragmentableArray<Permission>>(
    args?: {
      where?: PermissionWhereInput;
      orderBy?: PermissionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  resetToken: () => Promise<AsyncIterator<String>>;
  resetTokenExpiry: () => Promise<AsyncIterator<Float>>;
  lists: <T = Promise<AsyncIterator<ListSubscription>>>(
    args?: {
      where?: ListWhereInput;
      orderBy?: ListOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  items: <T = Promise<AsyncIterator<ItemSubscription>>>(
    args?: {
      where?: ItemWhereInput;
      orderBy?: ItemOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  permissions: <T = Promise<AsyncIterator<PermissionSubscription>>>(
    args?: {
      where?: PermissionWhereInput;
      orderBy?: PermissionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface PermissionSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface PermissionSubscriptionPayloadPromise
  extends Promise<PermissionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = Permission>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PermissionPreviousValues>() => T;
}

export interface PermissionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PermissionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PermissionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PermissionPreviousValuesSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface ListPreviousValues {
  id: ID_Output;
  title: String;
  type: ListType;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ListPreviousValuesPromise
  extends Promise<ListPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  type: () => Promise<ListType>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ListPreviousValuesSubscription
  extends Promise<AsyncIterator<ListPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  type: () => Promise<AsyncIterator<ListType>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ListSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface ListSubscriptionPayloadPromise
  extends Promise<ListSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = List>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ListPreviousValues>() => T;
}

export interface ListSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ListSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ListSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ListPreviousValuesSubscription>() => T;
}

export interface Stock {
  id: ID_Output;
  quantity?: Int;
  status?: StockStatus;
  unit?: Unit;
}

export interface StockPromise extends Promise<Stock>, Fragmentable {
  id: () => Promise<ID_Output>;
  listId: <T = List>() => T;
  itemId: <T = Item>() => T;
  quantity: () => Promise<Int>;
  status: () => Promise<StockStatus>;
  unit: () => Promise<Unit>;
}

export interface StockSubscription
  extends Promise<AsyncIterator<Stock>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  listId: <T = ListSubscription>() => T;
  itemId: <T = ItemSubscription>() => T;
  quantity: () => Promise<AsyncIterator<Int>>;
  status: () => Promise<AsyncIterator<StockStatus>>;
  unit: () => Promise<AsyncIterator<Unit>>;
}

export interface StockConnection {}

export interface StockConnectionPromise
  extends Promise<StockConnection>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = FragmentableArray<StockEdge>>() => T;
  aggregate: <T = AggregateStock>() => T;
}

export interface StockConnectionSubscription
  extends Promise<AsyncIterator<StockConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<StockEdgeSubscription>>>() => T;
  aggregate: <T = AggregateStockSubscription>() => T;
}

export interface AggregateList {
  count: Int;
}

export interface AggregateListPromise
  extends Promise<AggregateList>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateListSubscription
  extends Promise<AsyncIterator<AggregateList>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PermissionEdge {
  cursor: String;
}

export interface PermissionEdgePromise
  extends Promise<PermissionEdge>,
    Fragmentable {
  node: <T = Permission>() => T;
  cursor: () => Promise<String>;
}

export interface PermissionEdgeSubscription
  extends Promise<AsyncIterator<PermissionEdge>>,
    Fragmentable {
  node: <T = PermissionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

export type Long = string;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point). 
*/
export type Float = number;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/**
 * Model Metadata
 */

export const models = [
  {
    name: "Item",
    embedded: false
  },
  {
    name: "List",
    embedded: false
  },
  {
    name: "ListType",
    embedded: false
  },
  {
    name: "Permission",
    embedded: false
  },
  {
    name: "PermissionType",
    embedded: false
  },
  {
    name: "Stock",
    embedded: false
  },
  {
    name: "StockStatus",
    embedded: false
  },
  {
    name: "Unit",
    embedded: false
  },
  {
    name: "User",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const Prisma = makePrismaClientClass<ClientConstructor<Prisma>>({
  typeDefs,
  models,
  endpoint: `${process.env["PRISMA_ENDPOINT"]}`
});
export const prisma = new Prisma();
